import { sql } from 'kysely'
import * as fs from 'node:fs/promises'
import * as path from 'node:path'
import { isPrimitiveDataType } from '../../db/dataTypes.js'
import _db from '../../db/index.js'
import DreamApp from '../../dream-app/index.js'
import { DreamConst } from '../../dream/constants.js'
import FailedToIdentifyAssociation from '../../errors/schema-builder/FailedToIdentifyAssociation.js'
import camelize from '../camelize.js'
import compact from '../compact.js'
import EnvInternal from '../EnvInternal.js'
import intersection from '../intersection.js'
import pascalize from '../pascalize.js'
import sortBy from '../sortBy.js'
import uniq from '../uniq.js'
import autogeneratedFileDisclaimer from './autoGeneratedFileDisclaimer.js'
import { HasManyStatement } from '../../types/associations/hasMany.js'

export default class SchemaBuilder {
  public hasForeignKeyError: boolean = false

  public async build() {
    const { schemaConstContent, passthroughColumns, allDefaultScopeNames } = await this.buildSchemaContent()
    const imports = await this.getSchemaImports(schemaConstContent)

    const importStr = imports.length
      ? `\
import {
  ${imports.sort().join(',\n  ')}
} from './db.js'`
      : ''

    const calendarDateImportStatement = EnvInternal.boolean('DREAM_CORE_DEVELOPMENT')
      ? "import type CalendarDate from '../../src/helpers/CalendarDate.js'\nimport { type DateTime } from '../../src/helpers/DateTime.js'"
      : "import { type CalendarDate, type DateTime } from '@rvoh/dream'"

    const dreamApp = DreamApp.getOrFail()

    const newSchemaFileContents = `\
${autogeneratedFileDisclaimer()}
${calendarDateImportStatement}
${importStr}

${schemaConstContent}

export const globalSchema = {
  passthroughColumns: ${stringifyArray(uniq(passthroughColumns.sort()), { indent: 4 })},
  allDefaultScopeNames: ${stringifyArray(uniq(allDefaultScopeNames.sort()), { indent: 4 })},
  globalNames: {
    models: ${this.globalModelNames()},
    serializers: ${stringifyArray(Object.keys(dreamApp.serializers || {}).sort(), { indent: 6 })},
  },
} as const
`
    // const newSchemaFileContents = `\
    // ${schemaConstContent}
    // `
    const schemaPath = path.join(dreamApp.projectRoot, dreamApp.paths.types, 'dream.ts')
    await fs.writeFile(schemaPath, newSchemaFileContents)
  }

  private globalModelNames() {
    const dreamApp = DreamApp.getOrFail()
    const models = dreamApp.models

    return `{
      ${Object.keys(models)
        .map(key => `'${key}': '${models[key]?.prototype?.table}'`)
        .join(',\n      ')}
    }`
  }

  private async buildSchemaContent() {
    let passthroughColumns: string[] = []
    let allDefaultScopeNames: string[] = []

    const schemaData = await this.getSchemaData()
    const fileContents = await this.loadDbSyncFile()

    const schemaConstContent = `\
export const schema = {
  ${Object.keys(schemaData)
    .map(tableName => {
      const tableData = schemaData[tableName as keyof typeof schemaData]
      if (tableData === undefined) return ''
      const defaultScopeNames = tableData.scopes.default
      const namedScopeNames = tableData.scopes.named
      allDefaultScopeNames = [...allDefaultScopeNames, ...defaultScopeNames]

      const schemaDatum = schemaData[tableName]
      if (schemaDatum === undefined) return ''

      return `\
${tableName}: {
    primaryKey: '${tableData.primaryKey}',
    createdAtField: '${tableData.createdAtField}',
    updatedAtField: '${tableData.updatedAtField}',
    deletedAtField: '${tableData.deletedAtField}',
    serializerKeys: ${stringifyArray(tableData.serializerKeys)},
    scopes: {
      default: ${stringifyArray(defaultScopeNames)},
      named: ${stringifyArray(namedScopeNames)},
    },
    nonJsonColumnNames: ${stringifyArray(
      Object.keys(schemaDatum.columns).filter(
        columnName =>
          !['json', 'jsonb', 'json[]', 'jsonb[]'].includes(
            tableData.columns[columnName as keyof typeof tableData.columns]!.dbType
          )
      )
    )},
    columns: {
      ${Object.keys(schemaDatum.columns)
        .sort()
        .map(columnName => {
          const columnData = tableData.columns[columnName as keyof typeof tableData.columns]
          if (columnData === undefined) return ''
          const kyselyType = this.kyselyType(tableName, columnName, fileContents)
          if (kyselyType === undefined) return ''

          return `${columnName}: {
        coercedType: {} as ${this.coercedType(kyselyType, columnData.dbType)},
        enumType: ${columnData.enumType ? `{} as ${columnData.enumType}` : 'null'},
        enumArrayType: ${columnData.enumType ? `[] as ${columnData.enumType}[]` : 'null'},
        enumValues: ${columnData.enumValues ?? 'null'},
        dbType: '${columnData.dbType}',
        allowNull: ${columnData.allowNull},
        isArray: ${columnData.isArray},
      },`
        })
        .join('\n      ')}
    },
    virtualColumns: ${stringifyArray(schemaDatum.virtualColumns)},
    associations: {
      ${Object.keys(schemaDatum.associations)
        .sort()
        .map(associationName => {
          const associationMetadata = tableData.associations[associationName as keyof typeof tableData]
          if (associationMetadata === undefined) return ''
          const whereStatement = associationMetadata.where
          const requiredOnClauses =
            whereStatement === null
              ? []
              : Object.keys(whereStatement).filter(column => whereStatement[column] === DreamConst.required)
          passthroughColumns =
            whereStatement === null
              ? passthroughColumns
              : [
                  ...passthroughColumns,
                  ...Object.keys(whereStatement).filter(
                    column => whereStatement[column] === DreamConst.passthrough
                  ),
                ]
          return `${associationName}: {
        type: '${associationMetadata.type}',
        foreignKey: ${associationMetadata.foreignKey ? `'${associationMetadata.foreignKey}'` : 'null'},
        tables: ${stringifyArray(associationMetadata.tables)},
        optional: ${associationMetadata.optional},
        requiredOnClauses: ${requiredOnClauses.length === 0 ? 'null' : stringifyArray(requiredOnClauses)},
      },`
        })
        .join('\n      ')}
    },
  },\
`
    })
    .join('\n  ')}
} as const`

    return { schemaConstContent, passthroughColumns, allDefaultScopeNames }
  }

  private async getSchemaImports(schemaContent: string) {
    const allExports = await this.getExportedModulesFromDbSync()

    const schemaContentWithoutImports = schemaContent.replace(/import {[^}]*}/gm, '')
    return allExports.filter(exportedModule => {
      if (new RegExp(`coercedType: {} as ${exportedModule}`).test(schemaContentWithoutImports)) return true
      if (new RegExp(`coercedType: {} as ArrayType<${exportedModule}`).test(schemaContentWithoutImports))
        return true
      if (new RegExp(`enumType: {} as ${exportedModule}`).test(schemaContentWithoutImports)) return true
      if (new RegExp(`enumValues: ${exportedModule}`).test(schemaContentWithoutImports)) return true

      return false
    })
  }

  private async tableData(tableName: string) {
    const dreamApp = DreamApp.getOrFail()
    const models = Object.values(dreamApp.models).filter(model => model.table === tableName)
    const maybeModel = models[0]

    if (!maybeModel)
      throw new Error(`
Could not find a Dream model with table "${tableName}".

If you recently changed the name of a table in a migration, you
may need to update the table getter in the corresponding Dream.
`)

    const baseModel = maybeModel['stiBaseClassOrOwnClass']

    const associationData = this.getAssociationData(tableName)
    const allStiChildren = models.filter(model => model['isSTIChild'])
    const modelsToCheck = allStiChildren.length ? allStiChildren : [baseModel]

    // If a table is STI, then we look only at the serializers attached to
    // all STI children (not the STI base model because the base model may not have any serializers)
    const eachModelSerializerKeys = modelsToCheck.map(model => {
      let serializers: Record<string, string> = {}

      try {
        serializers = (model as any)?.prototype?.['serializers'] || {}
      } catch {
        // no-op
      }

      return Object.keys(serializers)
    })

    const serializerKeys = intersection(...eachModelSerializerKeys)

    return {
      primaryKey: baseModel.prototype.primaryKey,
      createdAtField: baseModel.prototype.createdAtField,
      updatedAtField: baseModel.prototype.updatedAtField,
      deletedAtField: baseModel.prototype.deletedAtField,
      scopes: {
        default: uniq(
          models.flatMap(model => model['scopes'].default.map(scopeStatement => scopeStatement.method))
        ),
        named: uniq(
          models.flatMap(model => model['scopes'].named.map(scopeStatement => scopeStatement.method))
        ),
      },
      columns: await this.getColumnData(tableName, associationData),
      virtualColumns: uniq(
        models.flatMap(model => model['virtualAttributes'].map(prop => prop.property) || [])
      ),
      associations: associationData,
      serializerKeys,
    }
  }

  private async getColumnData(tableName: string, associationData: { [key: string]: AssociationData }) {
    const db = _db('primary')
    const sqlQuery = sql`SELECT column_name, udt_name::regtype, is_nullable, data_type FROM information_schema.columns WHERE table_name = ${tableName}`
    const columnToDBTypeMap = await sqlQuery.execute(db)
    const rows = columnToDBTypeMap.rows as InformationSchemaRow[]

    const columnData: {
      [key: string]: ColumnData
    } = {}
    rows.forEach(row => {
      const isEnum = ['USER-DEFINED', 'ARRAY'].includes(row.dataType) && !isPrimitiveDataType(row.udtName)
      const isArray = ['ARRAY'].includes(row.dataType)
      const associationMetadata = associationData[row.columnName]

      columnData[camelize(row.columnName)] = {
        dbType: row.udtName,
        allowNull: row.isNullable === 'YES',
        enumType: isEnum ? this.enumType(row) : null,
        enumValues: isEnum ? `${this.enumType(row)}Values` : null,
        isArray,
        foreignKey: associationMetadata?.foreignKey || null,
      }
    })

    return Object.keys(columnData)
      .sort()
      .reduce(
        (acc, key) => {
          if (columnData[key] === undefined) return acc
          acc[key] = columnData[key]
          return acc
        },
        {} as { [key: string]: ColumnData }
      )
  }

  private enumType(row: InformationSchemaRow) {
    const enumName = pascalize(row.udtName.replace(/\[\]$/, ''))
    return enumName
  }

  private async getSchemaData() {
    const tables = await this.getTables()

    const schemaData: SchemaData = {}
    for (const table of tables) {
      schemaData[table] = await this.tableData(table)
    }

    return schemaData
  }

  private getAssociationData(tableName: string, targetAssociationType?: string) {
    const dreamApp = DreamApp.getOrFail()
    const models = sortBy(Object.values(dreamApp.models), m => m.table)
    const tableAssociationData: { [key: string]: AssociationData } = {}

    for (const model of models.filter(model => model.table === tableName)) {
      for (const associationName of model.associationNames) {
        const associationMetaData = model['associationMetadataMap']()[associationName]
        if (associationMetaData === undefined) continue
        if (targetAssociationType && associationMetaData.type !== targetAssociationType) continue

        const dreamClassOrClasses = associationMetaData.modelCB()
        if (!dreamClassOrClasses)
          throw new FailedToIdentifyAssociation(
            model,
            associationMetaData.type,
            associationName,
            associationMetaData.globalAssociationNameOrNames
          )

        const optional =
          associationMetaData.type === 'BelongsTo' ? associationMetaData.optional === true : null

        const where =
          associationMetaData.type === 'HasMany' || associationMetaData.type === 'HasOne'
            ? associationMetaData.and || null
            : null

        // NOTE
        // this try-catch is here because the SchemaBuilder currently needs to be run twice to generate foreignKey
        // correctly. The first time will raise, since calling Dream.columns is dependant on the schema const to
        // introspect columns during a foreign key check. This will be repaired once kysely types have been successfully
        // split off into a separate file from the types we diliver in types/dream.ts
        let foreignKey: string | null = null
        try {
          const isThroughAssociation = (associationMetaData as HasManyStatement<any, any, any, any>).through

          if (!isThroughAssociation) {
            const _foreignKey = associationMetaData.foreignKey()
            foreignKey = _foreignKey
          }
        } catch (err) {
          this.hasForeignKeyError = true
          // console.error(err)
        }

        tableAssociationData[associationName] ||= {
          tables: [],
          type: associationMetaData.type,
          polymorphic: associationMetaData.polymorphic,
          foreignKey,
          optional,
          where,
        }

        if (foreignKey) tableAssociationData[associationName]['foreignKey'] = foreignKey

        if (Array.isArray(dreamClassOrClasses)) {
          const tables: string[] = dreamClassOrClasses.map(dreamClass => dreamClass.table)

          tableAssociationData[associationName].tables = [
            ...tableAssociationData[associationName].tables,
            ...tables,
          ]
        } else {
          tableAssociationData[associationName].tables.push(dreamClassOrClasses.table)
        }

        // guarantee unique
        tableAssociationData[associationName].tables = [
          ...new Set(tableAssociationData[associationName].tables),
        ]
      }
    }

    return Object.keys(tableAssociationData)
      .sort()
      .reduce(
        (acc, key) => {
          if (tableAssociationData[key] === undefined) return acc
          acc[key] = tableAssociationData[key]
          return acc
        },
        {} as { [key: string]: AssociationData }
      )
  }

  private async getExportedModulesFromDbSync() {
    const fileContents: string = await this.loadDbSyncFile()
    const exportedConsts = [...fileContents.matchAll(/export\s+const\s+([a-zA-Z0-9_]+)/g)].map(res => res[1])
    const exportedTypes = [...fileContents.matchAll(/export\s+type\s+([a-zA-Z0-9_]+)/g)].map(res => res[1])
    const exportedInterfaces = [...fileContents.matchAll(/export\s+interface\s+([a-zA-Z0-9_]+)/g)].map(
      res => res[1]
    )

    const allExports: string[] = compact([...exportedConsts, ...exportedTypes, ...exportedInterfaces])
    return allExports
  }

  private async getTables() {
    const fileContents = await this.loadDbSyncFile()
    const tableLines = /export interface DB {([^}]*)}/.exec(fileContents)![1]
    if (tableLines === undefined) return []

    const tables = tableLines
      .split('\n')
      .map(line => {
        const stingArray = line.split(':')
        const substring = stingArray[0]
        if (substring === undefined) return ''
        return substring.replace(/\s*/, '')
      })
      .filter(line => !!line)
    return tables
  }

  private kyselyType(tableName: string, columnName: string, fileContents: string) {
    const tableLinesString = /export interface DB {([^}]*)}/.exec(fileContents)![1]
    if (tableLinesString === undefined) return ''

    const tableLines = tableLinesString
      .split('\n')
      .filter(line => !!line)
      .filter(line => new RegExp(`^  ${tableName}:`).test(line))

    const tableLine = tableLines[0]
    if (tableLine === undefined) return ''

    const interfaceName = tableLine.split(':')[1]?.replace(/[\s;]*/g, '')

    const interfaceLinesString = new RegExp(`export interface ${interfaceName} {([^}]*)}`).exec(
      fileContents
    )![1]
    if (interfaceLinesString === undefined) return ''

    const interfaceLines = interfaceLinesString
      .split('\n')
      .filter(line => !!line)
      .filter(line => new RegExp(`  ${columnName}:`).test(line))

    const interfaceLine = interfaceLines[0]
    if (interfaceLine === undefined) return ''

    const kyselyType = interfaceLine.split(':')[1]?.replace(/[\s;]*/g, '')

    return kyselyType
  }

  private coercedType(kyselyType: string, dbType: string) {
    const postfix = /\[\]$/.test(dbType) ? '[]' : ''

    return kyselyType
      .replace(/\s/g, '')
      .replace(/Generated<(.*)>/g, '$1')
      .replace(/ArrayType<(.*)>/g, '$1[]')
      .split('|')
      .map(individualType => {
        switch (individualType) {
          case 'Numeric':
          case 'Numeric[]':
            return `number${postfix}`

          case 'Timestamp':
          case 'Timestamp[]':
            return /^date[[\]]*$/.test(dbType) ? `CalendarDate${postfix}` : `DateTime${postfix}`

          case 'Int8':
          case 'Int8[]':
            return `IdType${postfix}`

          default:
            return individualType
        }
      })
      .join(' | ')
  }

  private async loadDbSyncFile() {
    const dreamApp = DreamApp.getOrFail()
    const dbSyncPath = path.join(dreamApp.projectRoot, dreamApp.paths.types, 'db.ts')
    return (await fs.readFile(dbSyncPath)).toString()
  }
}

function stringifyArray(
  arr: readonly string[] | string[] = [],
  { indent }: { indent?: number } = {}
): string {
  if (indent && arr.length > 3) {
    let spaces = ''
    for (let i = 0; i < indent; i++) {
      spaces = `${spaces} `
    }

    return `[
${spaces}${[...arr]
      .sort()
      .map(val => `'${val}'`)
      .join(`,\n${spaces}`)}
${spaces.replace(/\s{2}$/, '')}]`
  } else {
    return `[${[...arr]
      .sort()
      .map(val => `'${val}'`)
      .join(', ')}]`
  }
}

interface SchemaData {
  [key: string]: TableData
}

interface TableData {
  primaryKey: string
  createdAtField: string
  updatedAtField: string
  deletedAtField: string
  serializerKeys: readonly string[]
  scopes: {
    default: readonly string[]
    named: readonly string[]
  }
  columns: Readonly<{ [key: string]: ColumnData }>
  virtualColumns: readonly string[]
  associations: Readonly<{ [key: string]: AssociationData }>
}

interface AssociationData {
  tables: string[]
  type: 'BelongsTo' | 'HasOne' | 'HasMany'
  polymorphic: boolean
  optional: boolean | null
  foreignKey: string | null
  where: Record<string, string | typeof DreamConst.passthrough | typeof DreamConst.required> | null
}

interface ColumnData {
  dbType: string
  allowNull: boolean
  enumType: string | null
  enumValues: string | null
  isArray: boolean
  foreignKey: string | null
}

interface InformationSchemaRow {
  columnName: string
  udtName: string
  dataType: string
  isNullable: 'YES' | 'NO'
}
