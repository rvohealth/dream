import ts from 'typescript'
import { CliFileWriter } from '../../cli/CliFileWriter.js'
import camelize from '../camelize.js'
import ASTConnectionBuilder from './ASTConnectionBuilder.js'
import autogeneratedFileDisclaimer from './autoGeneratedFileDisclaimer.js'

const f = ts.factory

/**
 * Responsible for enhancing the kysely-codegen output, which can be found at
 * types/db.ts. If you are leveraging multiple db connections,
 * then this file will also be responsible for building all variants,
 * i.e. types/db.alternateConnection.ts, etc...
 *
 * This class leverages internal AST building mechanisms built into
 * typescript to manually build up object literals and interfaces
 * for our app to consume.
 */
export default class ASTKyselyCodegenEnhancer extends ASTConnectionBuilder {
  /**
   * enhances the kysely codegen output for the given connection name
   * by reading the relevant db.ts file into AST nodes, then enhancing them
   * with a variety of transformations necessary to lock this file in with
   * our other schema files, allowing types to flow correctly throughout the app.
   */
  public async enhance() {
    let dbSourceFile = await this.getDbSourceFile()
    dbSourceFile = this.camelizeKeys(dbSourceFile)
    dbSourceFile = this.replaceTimestampExport(dbSourceFile)
    dbSourceFile = await this.replaceTimeFieldsInInterfaces(dbSourceFile)
    dbSourceFile = this.addMissingImports(dbSourceFile)
    dbSourceFile = this.replaceInt8Export(dbSourceFile)
    dbSourceFile = this.sortExportedInterfacesTransformer(dbSourceFile)
    dbSourceFile = await this.addEnumValueExports(dbSourceFile)
    dbSourceFile = this.addDeprecatedDbClassExportForBackwardsCompatibility(dbSourceFile)

    const output = this.printOutput(dbSourceFile)
    const finalOutput = await this.prettier(`\
${autogeneratedFileDisclaimer()}
${output}`)

    await CliFileWriter.write(this.dbPath(), finalOutput)
  }

  private addDeprecatedDbClassExportForBackwardsCompatibility(dbSourceFile: ts.SourceFile) {
    const transformer: ts.TransformerFactory<ts.SourceFile> = () => {
      return sourceFile => {
        const dbInterface = this.findDbExport(sourceFile, 'DB') as ts.InterfaceDeclaration
        if (!dbInterface) return sourceFile

        const classDec = ts.factory.createClassDeclaration(
          [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
          ts.factory.createIdentifier('DBClass'),
          undefined,
          [],
          dbInterface.members.filter(ts.isPropertySignature).map(propertySignature => {
            return f.createPropertyDeclaration(
              [],
              propertySignature.name,
              undefined,
              propertySignature.type,
              undefined
            )
          })
        )

        return ts.factory.updateSourceFile(
          sourceFile,
          [...sourceFile.statements, classDec],
          sourceFile.isDeclarationFile,
          sourceFile.referencedFiles,
          sourceFile.typeReferenceDirectives,
          undefined
        )
      }
    }

    const result = ts.transform(dbSourceFile, [transformer])
    return result.transformed[0]!
  }

  /**
   * @internal
   *
   * returns the output of the provided dbSourceFile, ensuring that all exports
   * have a new line above them.
   */
  private printOutput(dbSourceFile: ts.SourceFile) {
    const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed })
    const output = printer.printNode(ts.EmitHint.SourceFile, dbSourceFile, dbSourceFile)
    return output.replace(/export /g, '\nexport ')
  }

  /**
   * @internal
   *
   * ensures that the `Timestamp` exported from db.ts points correctly to either
   * the DateTime or CalendarDate class, depending on the db type.
   */
  private replaceTimestampExport(dbSourceFile: ts.SourceFile) {
    const transformer: ts.TransformerFactory<ts.Node> = context => {
      return rootNode => {
        const visit = (node: ts.Node): ts.Node => {
          const typeAlias = this.exportedTypeAliasOrNull(node, 'Timestamp')

          if (typeAlias) {
            const updatedNode = f.updateTypeAliasDeclaration(
              typeAlias,
              typeAlias.modifiers,
              typeAlias.name,
              typeAlias.typeParameters,
              f.createTypeReferenceNode('ColumnType', [
                f.createUnionTypeNode([
                  f.createTypeReferenceNode(f.createIdentifier('DateTime')),
                  f.createTypeReferenceNode(f.createIdentifier('CalendarDate')),
                ]),
              ])
            )
            return updatedNode
          }

          return ts.visitEachChild(node, visit, context)
        }

        return ts.visitNode(rootNode, visit)
      }
    }

    const result = ts.transform(dbSourceFile, [transformer])
    return result.transformed[0]! as ts.SourceFile
  }

  /**
   * @internal
   *
   * Replaces string types with TimeWithZone or TimeWithoutZone for TIME columns
   * based on the schema metadata from dream.ts
   */
  private async replaceTimeFieldsInInterfaces(dbSourceFile: ts.SourceFile): Promise<ts.SourceFile> {
    const schemaData = await this.getSchemaData()

    const transformer: ts.TransformerFactory<ts.SourceFile> = context => {
      return sourceFile => {
        const visitor = (node: ts.Node): ts.Node => {
          if (ts.isInterfaceDeclaration(node) && node.name.text !== 'DB') {
            const tableName = this.toSnakeCase(node.name.text)
            const tableSchema = schemaData[tableName]

            if (!tableSchema) {
              return ts.visitEachChild(node, visitor, context)
            }

            const updatedMembers = node.members.map(member => {
              if (ts.isPropertySignature(member) && ts.isIdentifier(member.name)) {
                const columnName = member.name.text
                const columnSchema = tableSchema.columns[columnName]

                if (!columnSchema) return member

                const dbType = columnSchema.dbType

                // Check if this is a TIME field that's currently typed as string
                if (
                  (dbType === 'time without time zone' || dbType === 'time with time zone') &&
                  member.type
                ) {
                  const isTimeWithZone = dbType === 'time with time zone'
                  const timeTypeName = isTimeWithZone ? 'TimeWithZone' : 'TimeWithoutZone'

                  // Replace string with the appropriate Time class
                  const newType = this.replaceStringWithTimeType(member.type, timeTypeName, sourceFile)

                  if (newType !== member.type) {
                    return f.updatePropertySignature(
                      member,
                      member.modifiers,
                      member.name,
                      member.questionToken,
                      newType
                    )
                  }
                }
              }
              return member
            })

            return f.updateInterfaceDeclaration(
              node,
              node.modifiers,
              node.name,
              node.typeParameters,
              node.heritageClauses,
              updatedMembers
            )
          }

          return ts.visitEachChild(node, visitor, context)
        }

        return ts.visitNode(sourceFile, visitor) as ts.SourceFile
      }
    }

    const result = ts.transform(dbSourceFile, [transformer])
    return result.transformed[0]!
  }

  /**
   * @internal
   *
   * Helper to replace string type references with Time type references
   */
  private replaceStringWithTimeType(
    typeNode: ts.TypeNode,
    timeTypeName: string,
    sourceFile: ts.SourceFile
  ): ts.TypeNode {
    // Handle union types (e.g., string | null)
    if (ts.isUnionTypeNode(typeNode)) {
      const updatedTypes = typeNode.types.map(t => {
        if (ts.isTypeReferenceNode(t) && t.typeName.getText(sourceFile) === 'string') {
          return f.createTypeReferenceNode(f.createIdentifier(timeTypeName))
        }
        if (
          t.kind === ts.SyntaxKind.StringKeyword ||
          (ts.isLiteralTypeNode(t) && ts.isStringLiteral(t.literal))
        ) {
          return f.createTypeReferenceNode(f.createIdentifier(timeTypeName))
        }
        return t
      })
      return f.createUnionTypeNode(updatedTypes)
    }

    // Handle direct string type
    if (
      typeNode.kind === ts.SyntaxKind.StringKeyword ||
      (ts.isTypeReferenceNode(typeNode) && typeNode.typeName.getText(sourceFile) === 'string')
    ) {
      return f.createTypeReferenceNode(f.createIdentifier(timeTypeName))
    }

    return typeNode
  }

  /**
   * @internal
   *
   * Convert PascalCase to snake_case
   */
  private toSnakeCase(str: string): string {
    return str
      .replace(/([A-Z])/g, '_$1')
      .toLowerCase()
      .replace(/^_/, '')
  }

  /**
   * @internal
   *
   * massages the `Int8` exported from db.ts to make it more flexible
   */
  private replaceInt8Export(dbSourceFile: ts.SourceFile) {
    const transformer: ts.TransformerFactory<ts.Node> = context => {
      return rootNode => {
        const visit = (node: ts.Node): ts.Node => {
          const typeAlias = this.exportedTypeAliasOrNull(node, 'Int8')

          if (typeAlias) {
            return f.updateTypeAliasDeclaration(
              typeAlias,
              typeAlias.modifiers,
              typeAlias.name,
              typeAlias.typeParameters,
              f.createTypeReferenceNode('ColumnType', [
                f.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),
                f.createUnionTypeNode([
                  f.createKeywordTypeNode(ts.SyntaxKind.BigIntKeyword),
                  f.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),
                  f.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),
                ]),
                f.createUnionTypeNode([
                  f.createKeywordTypeNode(ts.SyntaxKind.BigIntKeyword),
                  f.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),
                  f.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),
                ]),
              ])
            )
          }

          return ts.visitEachChild(node, visit, context)
        }

        return ts.visitNode(rootNode, visit)
      }
    }

    const result = ts.transform(dbSourceFile, [transformer])
    return result.transformed[0]! as ts.SourceFile
  }

  /**
   * @internal
   *
   * injects missing CalendarDate and DateTime imports from dream
   */
  private addMissingImports(dbSourceFile: ts.SourceFile) {
    const transformer = () => {
      return (sourceFile: ts.SourceFile) =>
        f.updateSourceFile(sourceFile, [...this.dateAndDateTimeImports(), ...sourceFile.statements])
    }

    const result = ts.transform(dbSourceFile, [transformer])
    return result.transformed[0]!
  }

  /**
   * @internal
   *
   * sorts all exported interfaces and puts them above the DB interface
   */
  private sortExportedInterfacesTransformer(dbSourceFile: ts.SourceFile): ts.SourceFile {
    const transformer = () => {
      return (sourceFile: ts.SourceFile) => {
        const sortedInterfaceStatements: ts.InterfaceDeclaration[] = []
        const finalInterfaceStatements: ts.InterfaceDeclaration[] = []
        const otherStatements: ts.Statement[] = []

        sourceFile.statements.forEach(statement => {
          if (
            ts.isInterfaceDeclaration(statement) &&
            statement.modifiers?.some(m => m.kind === ts.SyntaxKind.ExportKeyword)
          ) {
            if (statement.name.text !== 'DB') {
              sortedInterfaceStatements.push(statement)
            } else {
              finalInterfaceStatements.push(statement)
            }
          } else {
            otherStatements.push(statement)
          }
        })

        sortedInterfaceStatements.sort((a, b) => a.name.text.localeCompare(b.name.text))

        return f.updateSourceFile(
          sourceFile,
          [...otherStatements, ...sortedInterfaceStatements, ...finalInterfaceStatements],
          sourceFile.isDeclarationFile,
          sourceFile.referencedFiles
        )
      }
    }

    const result = ts.transform(dbSourceFile, [transformer])
    return result.transformed[0]!
  }

  /**
   * @internal
   *
   * camelizes the keys on all interfaces except the DB interface
   * (since the DB interface is indexed by table name, which must not be camelized)
   */
  private camelizeKeys(dbSourceFile: ts.SourceFile) {
    // @ts-expect-error cannot lock this type down, though implementation is correct
    const transformer: ts.TransformerFactory<ts.SourceFile> = context => {
      const visit: ts.Visitor = node => {
        const interfaceNode = this.exportedInterfaceOrNull(node)

        if (
          interfaceNode &&
          !['DB'].includes(interfaceNode.name.text) // Check exclusion list
        ) {
          const updatedMembers = interfaceNode.members.map(member => {
            if (ts.isPropertySignature(member) && ts.isIdentifier(member.name)) {
              const camelizedKey = camelize(member.name.text)

              if (member.name.text !== camelizedKey) {
                return f.updatePropertySignature(
                  member,
                  member.modifiers,
                  f.createIdentifier(camelizedKey),
                  member.questionToken,
                  member.type
                )
              }
            }

            return member
          })

          return f.updateInterfaceDeclaration(
            interfaceNode,
            interfaceNode.modifiers,
            interfaceNode.name,
            interfaceNode.typeParameters,
            interfaceNode.heritageClauses,
            updatedMembers
          )
        }

        return ts.visitEachChild(node, visit, context)
      }

      return node => ts.visitNode(node, visit)
    }

    const result = ts.transform(dbSourceFile, [transformer])
    return result.transformed[0]!
  }

  /**
   * @internal
   *
   * for each found enum in the app (i.e. LocalizedTextsEnum), this will also
   * inject below it a `LocalizedTextsEnumValues` const, which can be used
   * at runtime to grab the actual enum values.
   */
  private async addEnumValueExports(dbSourceFile: ts.SourceFile) {
    const enums = await this.getAllEnumValueNames()
    const enumTypes = enums.map(e => e.enumType)

    // @ts-expect-error cannot lock this type down, though implementation is correct
    const transformer: ts.TransformerFactory<ts.SourceFile> = context => {
      const visit: ts.Visitor = (node): ts.Node | ts.Node[] => {
        const typeAlias = this.exportedTypeAliasOrNull(node)
        const isEnum = typeAlias ? enumTypes.includes(typeAlias.name.text) : false

        if (typeAlias && isEnum) {
          const literals: string[] = this.extractStringLiteralTypeNodesFromTypeOrUnion(typeAlias).map(
            node => node.literal.text
          )

          if (literals.length > 0) {
            return [
              typeAlias,
              f.createVariableStatement(
                [f.createModifier(ts.SyntaxKind.ExportKeyword)],
                f.createVariableDeclarationList(
                  [
                    f.createVariableDeclaration(
                      f.createIdentifier(`${typeAlias.name.text}Values`),
                      undefined,
                      undefined,
                      f.createAsExpression(
                        f.createArrayLiteralExpression(
                          literals.map(literal => f.createStringLiteral(literal)),
                          true // multiLine
                        ),
                        f.createKeywordTypeNode(ts.SyntaxKind.ConstKeyword as ts.KeywordTypeSyntaxKind)
                      )
                    ),
                  ],
                  ts.NodeFlags.Const
                )
              ),
            ]
          }
        }

        return ts.visitEachChild(node, visit, context)
      }

      return node => ts.visitNode(node, visit)
    }

    const result = ts.transform(dbSourceFile, [transformer])
    return result.transformed[0]!
  }
}
