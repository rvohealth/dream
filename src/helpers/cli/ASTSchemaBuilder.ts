import ts from 'typescript'
import { CliFileWriter } from '../../cli/CliFileWriter.js'
import { DreamConst } from '../../dream/constants.js'
import compact from '../compact.js'
import uniq from '../uniq.js'
import { TableData } from './ASTBuilder.js'
import ASTConnectionBuilder from './ASTConnectionBuilder.js'
import autogeneratedFileDisclaimer from './autoGeneratedFileDisclaimer.js'

const f = ts.factory

/**
 * Responsible for building dream schema, which can be found at
 * types/dream.ts. If you are leveraging multiple db connections,
 * then this file will also be responsible for building all variants,
 * i.e. types/dream.alternateConnection.ts, etc...
 *
 * This class leverages internal AST building mechanisms built into
 * typescript to manually build up object literals and interfaces
 * for our app to consume.
 */
export default class ASTSchemaBuilder extends ASTConnectionBuilder {
  /**
   * builds the new contents for the dream schema file (i.e. types/dream.ts
   * for default connection), and writes it to the file. This is automatically
   * done anytime the sync cli command is called, which happens when migrating,
   * rolling back, and when manually calling the sync command via CLI.
   */
  public async build() {
    // build a new, blank source file to populate with our output
    const sourceFile = ts.createSourceFile('', '', ts.ScriptTarget.Latest, false, ts.ScriptKind.TS)

    const { importedTypes, importedVariables, schemaConst, passthroughColumns, allDefaultScopeNames } =
      await this.buildSchemaConst()

    const output = await this.prettier(
      this.printStatements(
        [
          ...this.dateAndDateTimeImports(),
          this.dbImports(importedTypes, importedVariables),
          this.newLine(),
          schemaConst,
          this.newLine(),
          this.buildConnectionTypeConfigConst(passthroughColumns, allDefaultScopeNames),
        ],
        sourceFile
      )
    )

    await CliFileWriter.write(this.schemaPath(), output)
  }

  /**
   * @internal
   *
   * builds up the `export const schema = ...` statement within the dream.ts
   * file. It does this by leveraging low-level AST utils built into typescript
   * to manually build up an object literal, cast it as a const, and write it to
   * an exported variable.
   */
  private async buildSchemaConst() {
    const schemaData = await this.getSchemaData()
    const importedTypes: string[] = []
    const importedVariables: string[] = []
    let passthroughColumns: string[] = []
    let allDefaultScopeNames: string[] = []

    const dbSourceFile = await this.getDbSourceFile()

    const schemaObjectLiteral = f.createObjectLiteralExpression(
      Object.keys(schemaData).map(tableName => {
        const tableData = schemaData[tableName]!
        allDefaultScopeNames = [...allDefaultScopeNames, ...tableData.scopes.default]

        return f.createPropertyAssignment(
          f.createIdentifier(tableName),
          f.createObjectLiteralExpression(
            [
              f.createPropertyAssignment(
                f.createIdentifier('serializerKeys'),
                f.createArrayLiteralExpression(
                  tableData?.serializerKeys.map(key => f.createStringLiteral(key))
                )
              ),

              f.createPropertyAssignment(
                f.createIdentifier('scopes'),
                f.createObjectLiteralExpression(
                  [
                    f.createPropertyAssignment(
                      f.createIdentifier('default'),
                      f.createArrayLiteralExpression(
                        (tableData?.scopes.default as string[]).sort().map(key => f.createStringLiteral(key))
                      )
                    ),

                    f.createPropertyAssignment(
                      f.createIdentifier('named'),
                      f.createArrayLiteralExpression(
                        (tableData?.scopes.named as string[]).sort().map(key => f.createStringLiteral(key))
                      )
                    ),
                  ],
                  true // multiline
                )
              ),

              f.createPropertyAssignment(
                f.createIdentifier('nonJsonColumnNames'),
                f.createArrayLiteralExpression(
                  Object.keys(tableData?.columns || {})
                    .filter(
                      columnName =>
                        !['json', 'jsonb', 'json[]', 'jsonb[]'].includes(
                          tableData.columns[columnName as keyof typeof tableData.columns]!.dbType
                        )
                    )
                    .map(key => f.createStringLiteral(key))
                )
              ),

              f.createPropertyAssignment(
                f.createIdentifier('columns'),
                f.createObjectLiteralExpression(
                  Object.keys(tableData?.columns || {}).map(columnName => {
                    const columnData = tableData.columns[columnName]!

                    // any enums for these columns will need to be imported
                    // from the db.ts file in the same folder, so as we detect
                    // them, we push them into the importedModules array.
                    if (columnData.enumType) {
                      importedTypes.push(columnData.enumType)
                      importedVariables.push(columnData.enumType + 'Values')
                    }

                    const enumTypeNode = columnData.enumType
                      ? f.createTypeReferenceNode(
                          f.createIdentifier(columnData.enumType),
                          undefined // No type arguments needed here
                        )
                      : null

                    const enumValuesNode = columnData.enumType
                      ? f.createIdentifier(columnData.enumType + 'Values')
                      : f.createNull()

                    const coercedType = this.getCoercedTypeForTableColumn(
                      dbSourceFile,
                      tableName,
                      columnName,
                      tableData,
                      importedTypes
                    )

                    return f.createPropertyAssignment(
                      f.createIdentifier(columnName),
                      f.createObjectLiteralExpression(
                        [
                          f.createPropertyAssignment(
                            f.createIdentifier('coercedType'),
                            f.createAsExpression(f.createObjectLiteralExpression(), coercedType)
                          ),
                          f.createPropertyAssignment(
                            f.createIdentifier('enumType'),
                            enumTypeNode
                              ? f.createAsExpression(f.createObjectLiteralExpression(), enumTypeNode)
                              : f.createNull()
                          ),
                          f.createPropertyAssignment(
                            f.createIdentifier('enumArrayType'),
                            enumTypeNode
                              ? f.createAsExpression(
                                  f.createArrayLiteralExpression(),
                                  f.createArrayTypeNode(enumTypeNode)
                                )
                              : f.createNull()
                          ),
                          f.createPropertyAssignment(f.createIdentifier('enumValues'), enumValuesNode),
                          f.createPropertyAssignment(
                            f.createIdentifier('dbType'),
                            f.createStringLiteral(columnData.dbType)
                          ),
                          f.createPropertyAssignment(
                            f.createIdentifier('allowNull'),
                            columnData.allowNull ? f.createTrue() : f.createFalse()
                          ),
                          f.createPropertyAssignment(
                            f.createIdentifier('isArray'),
                            columnData.isArray ? f.createTrue() : f.createFalse()
                          ),
                        ],
                        true // multiline
                      )
                    )
                  }),
                  true // multiline
                )
              ),

              f.createPropertyAssignment(
                f.createIdentifier('virtualColumns'),
                f.createArrayLiteralExpression(
                  (tableData?.virtualColumns as string[] | undefined)
                    ?.sort()
                    ?.map(columnName => f.createStringLiteral(columnName))
                )
              ),

              f.createPropertyAssignment(
                f.createIdentifier('associations'),
                f.createObjectLiteralExpression(
                  Object.keys(tableData?.associations || {}).map(associationName => {
                    const associationMetadata = tableData.associations[associationName]!

                    const andStatement = associationMetadata.and
                    const requiredAndClauses =
                      andStatement === null
                        ? []
                        : Object.keys(andStatement).filter(
                            column => andStatement[column] === DreamConst.required
                          )
                    const passthroughAndClauses =
                      andStatement === null
                        ? []
                        : Object.keys(andStatement).filter(
                            column => andStatement[column] === DreamConst.passthrough
                          )
                    passthroughColumns = [...passthroughColumns, ...passthroughAndClauses]

                    return f.createPropertyAssignment(
                      f.createIdentifier(associationName),
                      f.createObjectLiteralExpression(
                        [
                          f.createPropertyAssignment(
                            f.createIdentifier('type'),
                            f.createStringLiteral(associationMetadata.type)
                          ),

                          f.createPropertyAssignment(
                            f.createIdentifier('foreignKey'),
                            associationMetadata.foreignKey
                              ? f.createStringLiteral(associationMetadata.foreignKey)
                              : f.createNull()
                          ),

                          f.createPropertyAssignment(
                            f.createIdentifier('foreignKeyTypeColumn'),
                            associationMetadata.foreignKeyTypeColumn
                              ? f.createStringLiteral(associationMetadata.foreignKeyTypeColumn)
                              : f.createNull()
                          ),

                          f.createPropertyAssignment(
                            f.createIdentifier('tables'),
                            f.createArrayLiteralExpression(
                              associationMetadata.tables.sort().map(table => f.createStringLiteral(table))
                            )
                          ),

                          f.createPropertyAssignment(
                            f.createIdentifier('optional'),
                            associationMetadata.optional === null
                              ? f.createNull()
                              : associationMetadata.optional
                                ? f.createTrue()
                                : f.createFalse()
                          ),

                          f.createPropertyAssignment(
                            f.createIdentifier('requiredAndClauses'),
                            requiredAndClauses.length === 0
                              ? f.createNull()
                              : f.createArrayLiteralExpression(
                                  requiredAndClauses.map(clause => f.createStringLiteral(clause))
                                )
                          ),

                          f.createPropertyAssignment(
                            f.createIdentifier('passthroughAndClauses'),
                            passthroughAndClauses.length === 0
                              ? f.createNull()
                              : f.createArrayLiteralExpression(
                                  passthroughAndClauses.map(clause => f.createStringLiteral(clause))
                                )
                          ),
                        ],
                        true // multiline
                      )
                    )
                  }),
                  true // multiline
                )
              ),
            ],
            true // multiline
          )
        )
      }),
      true // multiLine
    )

    // add "as const" to the end of the schema object we
    // have built before returning it
    const constAssertion = f.createAsExpression(
      schemaObjectLiteral,
      f.createKeywordTypeNode(ts.SyntaxKind.ConstKeyword as ts.KeywordTypeSyntaxKind)
    )

    const schemaConst = f.createVariableStatement(
      [f.createModifier(ts.SyntaxKind.ExportKeyword)],
      f.createVariableDeclarationList(
        [f.createVariableDeclaration(f.createIdentifier('schema'), undefined, undefined, constAssertion)],
        ts.NodeFlags.Const
      )
    )

    return {
      schemaConst,
      importedTypes: uniq(importedTypes).sort(),
      importedVariables: uniq(importedVariables).sort(),
      passthroughColumns: uniq(passthroughColumns).sort(),
      allDefaultScopeNames: uniq(allDefaultScopeNames).sort(),
    }
  }

  /**
   * @internal
   *
   * builds up the `export const connectionTypeConfig = ...` statement within the dream.ts
   * file. It does this by leveraging low-level AST utils built into typescript
   * to manually build up an object literal, cast it as a const, and write it to
   * an exported variable.
   */
  private buildConnectionTypeConfigConst(passthroughColumns: string[], allDefaultScopeNames: string[]) {
    const connectionTypeConfigObjectLiteral = f.createObjectLiteralExpression(
      [
        f.createPropertyAssignment(
          f.createIdentifier('passthroughColumns'),
          f.createArrayLiteralExpression(
            passthroughColumns.map(column => f.createStringLiteral(column)),
            true // multiline
          )
        ),

        f.createPropertyAssignment(
          f.createIdentifier('allDefaultScopeNames'),
          f.createArrayLiteralExpression(
            allDefaultScopeNames.map(column => f.createStringLiteral(column)),
            true // multiline
          )
        ),

        f.createPropertyAssignment(
          f.createIdentifier('globalNames'),
          f.createObjectLiteralExpression(
            [
              f.createPropertyAssignment(
                f.createIdentifier('models'),
                f.createObjectLiteralExpression(
                  this.globalModelNames().map(([globalName, tableName]) =>
                    f.createPropertyAssignment(
                      f.createStringLiteral(globalName),
                      f.createStringLiteral(tableName)
                    )
                  ),
                  true // multiline
                )
              ),
            ],
            true // multiline
          )
        ),
      ],
      true // multiline
    )

    // add "as const" to the end of the schema object we
    // have built before returning it
    const constAssertion = f.createAsExpression(
      connectionTypeConfigObjectLiteral,
      f.createKeywordTypeNode(ts.SyntaxKind.ConstKeyword as ts.KeywordTypeSyntaxKind)
    )

    const connectionTypeConfigObjectLiteralConst = f.createVariableStatement(
      [f.createModifier(ts.SyntaxKind.ExportKeyword)],
      f.createVariableDeclarationList(
        [
          f.createVariableDeclaration(
            f.createIdentifier('connectionTypeConfig'),
            undefined,
            undefined,
            constAssertion
          ),
        ],
        ts.NodeFlags.Const
      )
    )

    return connectionTypeConfigObjectLiteralConst
  }

  /**
   * @internal
   *
   * writes the compiled statements to string. Will also manually inject new lines
   * into the import statements, since otherwise, they are forced into a single line
   * and are completely unreadable that way.
   *
   * prettier is used in a later step to optimize output, but the user may not have
   * prettier installed, in which case it will do nothing, and we don't want to leave
   * the imports unformatted in those cases.
   */
  private printStatements(statements: ts.Node[], sourceFile: ts.SourceFile): string {
    const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed, omitTrailingSemicolon: true })
    const result = printer.printList(
      ts.ListFormat.SourceFileStatements,
      f.createNodeArray(statements),
      sourceFile
    )

    // manually replace single-line db imports with multi-line import
    const output = result
      .replace(/import\s*{\s*([^}]+)\s*}\s*from\s*"\.\/db.js"/, (_, names) => {
        // Split items, trim them, and rejoin with newlines + indentation
        const formatted = names
          .split(',')
          .map((n: string) => n.trim())
          .map((n: string) => `  ${n},`)
          .join('\n')

        return `import {\n${formatted}\n} from "./db.js"`
      })
      .replaceAll(/from ([^;]*);/g, 'from $1')

    return `\
${autogeneratedFileDisclaimer()}
${output}`
  }

  /**
   * @internal
   *
   * builds up an AST statement representing the DB imports that the dream.ts
   * file will need in order to render without import errors. It takes the aggregated
   * list of imported types and imported variables built up as the schema was being
   * built, and uses them to build AST import nodes, which can be rendered into the
   * schema source file.
   */
  private dbImports(importedTypes: string[], importedVariables: string[]) {
    const namedImports = f.createNamedImports([
      ...importedTypes.map(importName =>
        f.createImportSpecifier(true, undefined, f.createIdentifier(importName))
      ),
      ...importedVariables.map(importName =>
        f.createImportSpecifier(false, undefined, f.createIdentifier(importName))
      ),
    ])

    const importClause = f.createImportClause(false, undefined, namedImports)

    const importDeclaration = f.createImportDeclaration(
      undefined,
      importClause,
      f.createStringLiteral('./db.js'),
      undefined
    )

    return importDeclaration
  }

  /**
   * @internal
   *
   * given a column and table, this method returns the coerced type representation
   * of whatever type was found in the db.ts file. In most cases, it will simply
   * return the same type as was found, but in some cases it will perform coercion
   * to provide consistent and useful types to the underlying application.
   *
   * Amongst other things, it will convert Numeric -> number, Int8 -> string, etc...
   * Timestamp will be carefully converted to either CalendarDate or DateTime, depending
   * on if the type set in the db is a date or datetime field.
   */
  private getCoercedTypeForTableColumn(
    dbSourceFile: ts.SourceFile,
    tableName: string,
    columnName: string,
    tableData: TableData,
    importedModules: string[]
  ): ts.TypeNode {
    const columnData = tableData.columns[columnName]!
    const tableNode = this.getTableInterfaceDeclaration(dbSourceFile, tableName)
    const propertyNode = this.getPropertyFromInterface(tableNode, columnName)!
    const coercedTypes = this.coercedType(dbSourceFile, propertyNode, columnData.dbType, importedModules)

    return coercedTypes.length === 1 ? coercedTypes[0]! : f.createUnionTypeNode(coercedTypes)
  }

  /**
   * @internal
   *
   * used by the getCoercedTypeForTableColumn to get the specific type for a column
   * if no coercion is necessary, the original type node will be returned
   */
  private coercedType(
    dbSourceFile: ts.SourceFile,
    propertySignature: ts.PropertySignature,
    dbType: string,
    importedModules: string[]
  ): ts.TypeNode[] {
    const extractedPropertyTypes = this.extractTypeNodesFromTypeOrUnion(propertySignature)
    const isDate = /^date[[\]]*$/.test(dbType)

    const types = compact(
      extractedPropertyTypes.map(typeNode => {
        const typeText = typeNode.getText(dbSourceFile)
        let defaultReturnNode = /^Generated/.test(typeText) ? this.getFirstGenericType(typeNode)! : typeNode

        const modifiedText = defaultReturnNode.getText(dbSourceFile)
        defaultReturnNode = /^ArrayType/.test(modifiedText)
          ? f.createArrayTypeNode(this.getFirstGenericType(defaultReturnNode)!)
          : defaultReturnNode

        const sanitized = typeText
          .replace(/\s/g, '')
          .replace(/Generated<(.*)>/g, '$1')
          .replace(/ArrayType<(.*)>/g, '$1[]')
        if (sanitized === '') return null

        switch (sanitized) {
          case 'Numeric':
            return f.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword)

          case 'Numeric[]':
            return f.createArrayTypeNode(f.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword))

          case 'Timestamp':
            return isDate ? f.createTypeReferenceNode('CalendarDate') : f.createTypeReferenceNode('DateTime')

          case 'Timestamp[]':
            return isDate
              ? f.createArrayTypeNode(f.createTypeReferenceNode('CalendarDate'))
              : f.createArrayTypeNode(f.createTypeReferenceNode('DateTime'))

          case 'Int8':
            return f.createKeywordTypeNode(ts.SyntaxKind.StringKeyword)

          case 'Int8[]':
            return f.createArrayTypeNode(f.createKeywordTypeNode(ts.SyntaxKind.StringKeyword))

          case 'Json':
          case 'Json[]':
            importedModules.push('Json')
            return defaultReturnNode

          default:
            return defaultReturnNode
        }
      })
    )

    return types
  }
}
